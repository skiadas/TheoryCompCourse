<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="schedule">Schedule</h1>
<table>
<thead>
<tr class="header">
<th align="left">Week</th>
<th align="left">Tuesday</th>
<th align="left">Thursday</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Week 1 (09/03-9/07)</td>
<td align="left">1, 2</td>
<td align="left">3</td>
</tr>
<tr class="even">
<td align="left">Week 2 (09/10-09/14)</td>
<td align="left">4.1-4.3</td>
<td align="left">4.4-4.5</td>
</tr>
<tr class="odd">
<td align="left">Week 3 (09/17-09/21)</td>
<td align="left">5.1</td>
<td align="left">5.1</td>
</tr>
<tr class="even">
<td align="left">Week 4 (09/24-09/28)</td>
<td align="left">5.2</td>
<td align="left">5.3-5.7, Coding</td>
</tr>
<tr class="odd">
<td align="left">Week 5 (10/01-10/05)</td>
<td align="left"><a href="midterm1_study_guide.html">Midterm 1</a></td>
<td align="left">6.1, 6.2</td>
</tr>
<tr class="even">
<td align="left">Week 6 (10/08-10/12)</td>
<td align="left">7</td>
<td align="left">7</td>
</tr>
<tr class="odd">
<td align="left">Week 7 (10/15-10/19)</td>
<td align="left">Break</td>
<td align="left">7</td>
</tr>
<tr class="even">
<td align="left">Week 8 (10/22-10/26)</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
<tr class="odd">
<td align="left">Week 9 (10/29-11/02)</td>
<td align="left">9</td>
<td align="left">9</td>
</tr>
<tr class="even">
<td align="left">Week 10 (11/05-11/09)</td>
<td align="left">9</td>
<td align="left"><a href="midterm2_study_guide.html">Midterm 2</a></td>
</tr>
<tr class="odd">
<td align="left">Week 11 (11/12-11/16)</td>
<td align="left">CFGs</td>
<td align="left">CFGs</td>
</tr>
<tr class="even">
<td align="left">Week 12 (11/19-11/23)</td>
<td align="left">11</td>
<td align="left">Thanksgiving</td>
</tr>
<tr class="odd">
<td align="left">Week 13 (11/26-11/30)</td>
<td align="left">12</td>
<td align="left">13</td>
</tr>
<tr class="even">
<td align="left">Week 14 (12/03-12/07)</td>
<td align="left">13,14</td>
<td align="left">14</td>
</tr>
</tbody>
</table>
<h2 id="week-1-0903-907">Week 1 (09/03-9/07)</h2>
<h3 id="day-1">Day 1</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand the different kinds of problems we would investigate, with Python examples.</li>
<li>Understand what “Python programs” we will consider in this class.</li>
<li>Practice with string representations of standard kinds of inputs.</li>
</ul>
</dd>
<dt>Chapter 1</dt>
<dd><ul>
<li>Introduction to Theory of Computation</li>
<li>Different kinds of problems</li>
</ul>
</dd>
<dt>Activity 1</dt>
<dd><ul>
<li>Discuss examples of tractable/intractable/uncomputable problems.</li>
<li><a href="activities/activity1.html">Activity Handout</a></li>
</ul>
</dd>
<dt>Chapter 2</dt>
<dd><ul>
<li>What is a SISO Python program?</li>
<li>Input and Output of a program.</li>
<li>Practice programs (pseudocode sufficient, work at the board):
<ul>
<li>Takes a string input and runs forever (at least on some inputs).</li>
<li>Takes a string input and throws an exception (at least on some inputs).</li>
<li>Given a string representing a list of numbers separated by spaces, like “23 45 13”, add the numbers up and return the sum as a string.</li>
</ul></li>
<li>Exercise 2.5 a-d (work at the computers).</li>
<li>When are SISO programs equivalent? Examples of different but equivalent programs.</li>
<li>Decision programs.</li>
<li>Exercise 2.7 (talk with neighbor)</li>
</ul>
</dd>
<dt>Activity 2</dt>
<dd><ul>
<li>How can a SISO program process the following kinds of inputs:
<ul>
<li>A list of an arbitrary number of integers.</li>
<li>Two strings of predetermined length (say each of length 20).</li>
<li>Two strings of non-predetermined length.</li>
<li>Three strings of non-predetermined length.</li>
<li>A list of an arbitrary number of strings of non-predetermined length.</li>
</ul></li>
</ul>
</dd>
</dl>
<h3 id="day-2">Day 2</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand the fact that programs are simply strings and can be inputs to other programs.</li>
<li>Understand the difference between running a program and reasoning about a program’s execution.</li>
<li>Understand the limitations of programming languages by showing there are programs that cannot exist.</li>
</ul>
</dd>
<dt>Chapter 3</dt>
<dd><ul>
<li>Examples of decision programs: <code>containsGAGA</code>, <code>yes</code>, <code>longerThan1K</code>, <code>maybeLoop</code>.</li>
<li>The <code>countLines</code> program; programs as input to other programs.</li>
<li>Self-reflection: programs examining themselves (group work Figure 3.3).</li>
<li>The program <code>yesOnString</code>. Try at various inputs (group work Figure 3.4).</li>
<li>Python offers a command <code>exec</code>, which takes a Python file and executes it. Can we use it to implement the behavior described by <code>yesOnString</code> (group discussion)?</li>
<li>The program <code>yesOnSelf</code>. (group work Figure 3.5).</li>
<li>Write <code>yesOnSelf</code> using <code>yesOnString</code> as a helper.</li>
<li>The program <code>notYesOnSelf</code>. Think through what happens when <code>notYesOnSelf</code> is run with input the earlier programs, as well as itself. (group work).</li>
<li>Discussion of programs <code>crashOnString</code>, <code>crashOnSelf</code>, <code>weirdCrashOnSelf</code>.</li>
</ul>
</dd>
<dt>Activity 3</dt>
<dd><ul>
<li>Discuss definitions of the outputs of the programs <code>noOnString</code>, <code>noOnSelf</code>.</li>
<li>Are <code>noOnSelf</code> and <code>notYesOnSelf</code> equivalent programs, if they existed?</li>
<li>Is a similar conclusion possible for <code>noOnSelf</code> as for <code>notYesOnSelf</code>?</li>
<li>Exercise 3.3</li>
<li><a href="activities/activity3.html">Activity Handout</a></li>
</ul>
</dd>
<dt>HW 1 (Due 9/13 4pm in LYN 110)</dt>
<dd>3.2, 3.10, 3.11
</dd>
</dl>
<h2 id="week-2-0910-0914">Week 2 (09/10-09/14)</h2>
<h3 id="day-1-1">Day 1</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Review the basic methodology of proof by contradiction.</li>
<li>Understand the terms Alphabet, Language, String, in the Theory of Computation context.</li>
</ul>
</dd>
<dt>Chapter 3 recap</dt>
<dd><ul>
<li>Exercise 3.3</li>
<li>Review of proofs by contradiction.</li>
<li>Write a formal proof that the program <code>yesOnString</code> cannot exist.</li>
</ul>
</dd>
<dt>Section 4.1</dt>
<dd><ul>
<li>Computational Problems and how they differ from programs</li>
<li>Alphabets, Strings, (Formal) Languages</li>
<li>Exercise 4.3 (group discussion)</li>
<li>Various examples of languages and language constructions
<ul>
<li>Empty/All, containing empty string only, Python/Java programs</li>
<li>Strings accepted by a decision program</li>
<li>union/intersection/complement/concatenation/Kleene</li>
</ul></li>
<li>Activity 4, first two points</li>
</ul>
</dd>
<dt>Activity 4</dt>
<dd><ul>
<li>Describe three formal languages that are sufficiently different from those listed in the book.</li>
<li>Exercises 4.4, 4.6</li>
</ul>
</dd>
</dl>
<h3 id="day-2-1">Day 2</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Learn the basic terminology related to computational problems</li>
<li>Understand what it formally means to solve a problem.</li>
</ul>
</dd>
<dt>Review</dt>
<dd><ul>
<li>Consider the alphabet <span class="math inline">\(\Sigma=\{a,b\}\)</span>.
<ul>
<li>Give a clear English description of the language <span class="math inline">\(\Sigma^*\)</span>.</li>
<li>How many strings of length exactly <span class="math inline">\(4\)</span> are there in <span class="math inline">\(\Sigma^*\)</span>?</li>
<li>List all strings <span class="math inline">\(s\in\Sigma^*\)</span> with <span class="math inline">\(|s|&lt;3\)</span> in <strong>lexicographic order</strong>.</li>
</ul></li>
</ul>
</dd>
<dt>Sections 4.2-4.4</dt>
<dd><ul>
<li>Computational problems:
<ul>
<li>inputs, solution sets, positive and negative instances</li>
<li>Describe the SHORTESTPATH problem</li>
<li>Exercises 4.11, 4.13</li>
<li>Kinds of computational problems: search, optimization, threshold, function, decision</li>
<li>General computational problems vs decision problems. Figure 4.13</li>
<li>Exercise 4.15</li>
</ul></li>
<li>What does it mean to solve/compute/decide a computational problem? Provide both positive and negative examples.</li>
<li>Computable vs uncomputable problems. Provide examples of uncomputable problems.</li>
</ul>
</dd>
<dt>Practice</dt>
<dd><ul>
<li>Exercises 4.5, 4.7</li>
<li>The problem GREATER takes as input a number, and has as solutions all numbers that are greater than this number. Is this a computational problem according to our definition?</li>
<li>A <em>composite</em> number is a positive integer which has at least one non-trivial divisor. The problem FACTOR takes as input a number. If the number is composite, then the solution set is all of the number’s non-trivial divisors. If the number is prime, the solution is “no” indicating no solution. This can be described as a “search” problem. Express it as a search problem by specifying a predicate function.</li>
<li>Define “threshold”, “optimization” and “decision” versions of the previous problem that have an analogous computational difficulty.</li>
<li>Write a Python program that <em>decides</em> the language that contains all strings in the ASCII alphabet that have “matching parentheses”, meaning that every “open parenthesis” is going to be matched by a “close parenthesis”. The strings can contain any other letters inbetween.</li>
<li>(Optional, Challenge) Using HasShortPath as a helper function, write an algorithm for solving ShortestPath.</li>
</ul>
</dd>
<dt>HW 2 (Due 9/25 4pm in LYN 110)</dt>
<dd>4.12, 4.19, 4.20, 4.25a,b, Bonus problems: 4.25c, 4.26
</dd>
</dl>
<h2 id="week-3-0917-0921">Week 3 (09/17-09/21)</h2>
<h3 id="day-1-2">Day 1</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand the difference between decidable and recognizable languages.</li>
</ul>
</dd>
<dt>Section 4.5</dt>
<dd><ul>
<li>The membership problem for a language. The language corresponding to a decision problem.</li>
<li>Definition of decidable languages and decidable decision problems.</li>
<li>Is the language of Java Programs decidable?</li>
<li>Recognizable languages. Give examples of recognizable languages that are not decidable.</li>
</ul>
</dd>
<dt>Activity 5</dt>
<dd><ul>
<li>Write a Python program that <em>decides</em> the language of all (finite) binary strings that contain at least two 1s. (Food for thought: does this program have to worry about handling non-binary strings?)</li>
<li>Write a Python program that <em>decides</em> the language of all prime numbers.</li>
<li>Write Python programs that <em>decide</em> the empty language and the language consisting of just the empty string, respectively.</li>
</ul>
</dd>
</dl>
<h3 id="day-2-2">Day 2</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand the definition of a Turing machine</li>
<li>Understand the graphical representation of a Turing machine</li>
<li>Be able to follow the execution of a Turing machine on a given input</li>
</ul>
</dd>
<dt>Section 5.1</dt>
<dd><ul>
<li>Definition of a Turing machine: alphabet, states, transition functions</li>
<li>Transition function can be thought of as a combination of: new state function, new symbol function, direction function</li>
<li>What different final states can we have in a Turing machine? Are any of them required?</li>
<li>Write a Turing machine that given a string input accepts if the input has even length.</li>
<li>Describing a Turing machine via state diagrams instead of tables of transitions.</li>
<li>Abbreviated notation for state diagrams.</li>
<li>Show a complete computation.</li>
<li>Activity 6, first one</li>
<li>Write a Turing machine that inserts an x at the beginning of the input, shifting all other letters to the right, and also inserts an x at the end of the input.</li>
<li>What is the difference between <em>looping</em> and <em>halting</em>?</li>
<li>What Turing machines do we call <em>transducers</em> and what machines do we call <em>accepters</em>? Are those the only kinds of Turing machines?</li>
</ul>
</dd>
<dt>Activity 6</dt>
<dd><ul>
<li>Make a state diagram for a Turing machine that given a string input accepts if the input has even number of vowels and rejects otherwise.</li>
<li>Make a state diagram for a Turing machine that searches for the first C that occurs in the string and changes it to a G, then halts. If it arrives at the end of the input without finding a C, then it inserts a C and halts.</li>
<li>Consider the alphabet consisting of only the binary digits 0, 1. Consider the input as a number with the least significant digit being at the beginning of the tape. So if the number was 8, the tape would start with “001” with the first 0 being at the start of the tape. We will call this representation of numbers <em>reverse binary</em>. Make a state diagram for a Turing machine that would change the tape contents so that the final output is representing the input number incremented by 1. So in the example above the output would be “101”. And if we had started with “101” as input, then the output would be “011” etc.</li>
</ul>
</dd>
<dt>Homework 3 (Due 9/28 4pm in LYN 110)</dt>
<dd><ul>
<li>4.25b, 5.3 (but change it to “at least 2 Gs and at most 3 Ts”), 5.5, 5.6</li>
<li>Coderunner problem <code>isPrime</code> in Moodle</li>
</ul>
</dd>
</dl>
<h2 id="week-4-0924-0928">Week 4 (09/24-09/28)</h2>
<h3 id="day-1-3">Day 1</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand how a Turing machine can use the tape to remember an unbounded amount of information.</li>
</ul>
</dd>
<dt>Section 5.2</dt>
<dd><ul>
<li>A Turing machine that checks whether the string has more Cs than Gs. It follows two different paths depending on whether it encounters a G or a C first (decider).</li>
<li>Discuss “reverse binary” notation and operations.</li>
<li>Implement a Turing Machine that takes a “reverse binary” input enclosed by a pair of <code>x</code>s and increments its value by 1 (transducer).</li>
<li>Practice: Describe the expected behavior of a <code>reverseBinaryDecrementer</code> machine (should reject if the input is the number 0) and construct its state diagram.</li>
</ul>
</dd>
</dl>
<h3 id="day-2-3">Day 2</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand how a Turing machine can be used as a component/subprogram in another Turing machine.</li>
<li>Understand how two-tape and multi-tape machines have the same power as one-tape machines.</li>
<li>Understand how a Python program can simulate a Turing machine.</li>
<li>Understand how Python programs are computationally equivalent to Turing machines.</li>
<li>Practice writing and running Turing Machines in Python using simulateTM.</li>
</ul>
</dd>
<dt>Section 5.2</dt>
<dd><ul>
<li>Go through Problem 4.25</li>
<li>Use the reverse binary incrementer to implement a <code>countCs</code> Turing machine. Start by describing these helpers:
<ul>
<li><code>prependx</code></li>
<li><code>prepend0</code></li>
<li><code>incrementReverseBinary</code></li>
<li><code>moveHeadToNumberStart</code></li>
<li><code>moveHeadToStringStart</code></li>
<li><code>deleteString</code></li>
</ul></li>
</ul>
</dd>
<dt>Activity 7</dt>
<dd><ul>
<li>Create a state diagram for a Turing machine that compares two numbers as follows:
<ul>
<li>The numbers are provided in binary form from highest significant number to lowest, separated by x’s and with zeroes padded in if needed to make sure both numbers have the same number of digits. For example the numbers 6 and 2 would be represented as: “x110x010x”.</li>
<li>Your machine is free to change the tape contents as it needs to. You may also introduce up to two new symbols: y and z.</li>
<li>Your machine should accept if the first number is at least as large as the second, and it should simply halt if the second number is larger.</li>
<li>Is this machine a decider for a language? Explain.</li>
</ul></li>
</ul>
</dd>
<dt>Sections 5.3-5.7</dt>
<dd><ul>
<li>A two-tape single-head Turing machine can be simulated by a standard Turing machine by using an alphabet consisting of pairs of characters from the alphabet of the original machine (a “squared alphabet”).</li>
<li>A multi-tape single-head Turing machine can be simulated in a similar way.</li>
<li>A multi-tape multi-head Turing machine can be simulated by using a multi-tape single-head Turing machine that uses twice the number of tapes, and uses the second set of tapes to keep track of the locations of the multiple heads.</li>
<li>How can a Python program be used to simulate a Turing machine?</li>
<li>Talk about how it’s plausible that a Turing machine has the same computational power as Python.</li>
</ul>
</dd>
<dt>Activity 8</dt>
<dd><a href="activities/activity8.html">Activity 8 writeup</a>
</dd>
<dt>Homework 4 (Due 10/05 4pm in LYN 110)</dt>
<dd><ul>
<li>5.7, 5.13. For each Turing machine you create provide both a state diagram and a text description of the Turing machine as in the provided <code>.tm</code> files. (See also Fig. 5.19)</li>
<li>Write and test a single-tape Turing machine that implements the “<strong>reverse</strong> binary decrementer” that we discussed in class. Submit the printout of your <code>.tm</code> file. Include a state diagram.</li>
</ul>
</dd>
</dl>
<h2 id="week-5-1001-1005">Week 5 (10/01-10/05)</h2>
<h3 id="day-1-4">Day 1</h3>
<ul>
<li><a href="midterm1_study_guide.html">Midterm 1</a></li>
</ul>
<h3 id="day-2-4">Day 2</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand the idea of <em>universal computer programs</em> and <em>universal Turing machines</em>.</li>
<li>Familiarize yourself with programs that alter other programs.</li>
<li>Use a universal computer program to produce programs that are recognizers but not deciders.</li>
</ul>
</dd>
<dt>Sections 6.1, 6.4, 6.5 (6.3 optional)</dt>
<dd><ul>
<li>Understand the program <code>universal.py</code> and how it works.</li>
<li>Describe the “simulate-and-alter” technique for changing a program’s behavior (Figure 6.8).</li>
<li>Group activity: 6.4</li>
<li>Describe the input-ignoring program in Figure 6.9.</li>
<li>Show that YesOnString is recognizable.</li>
<li>Group activity: 6.6 (Actually write the program and run it on positive and negative instances)</li>
</ul>
</dd>
<dt>Activity 9</dt>
<dd><ul>
<li>Construct a program that demonstrates that the language CrashOnString is recognizable.</li>
</ul>
</dd>
<dt>Homework 5</dt>
<dd>(Due 10/11 4pm in LYN 110) 6.3, 6.7, 6.9 (make sure to actually write a Python program for it)
</dd>
</dl>
<h2 id="week-6-1008-1012">Week 6 (10/08-10/12)</h2>
<h3 id="day-1-5">Day 1</h3>
<dl>
<dt>Goals</dt>
<dd><ul>
<li>Understand what it means to have a <em>reduction</em> from problem A to problem B.</li>
<li>Use reduction arguments to prove one problem is <em>at least as hard</em> than another.</li>
</ul>
</dd>
<dt>Sections 7.1, 7.2, 7.3</dt>
<dd><ul>
<li>The <code>IsOdd</code> and <code>LastDigitIsEven</code> problems, and solving <code>IsOdd</code> via <code>LastDigitIsEven</code>.</li>
<li>Using a program that solves one problem to build a program that solves another.</li>
<li>Showing a program is impossible by using it to write a program that is known to be impossible.</li>
<li>Informal definition of the phrase “problem F reduces to problem G”</li>
<li>The problem <code>GAGAOnString</code> and proving it is undecidable via a reduction from <code>YesOnString</code>:
<ul>
<li>Transforming <em>instances</em> of <code>YesOnString</code> to instances of <code>GAGAOnString</code>.</li>
<li>Positive instances must map to positive instances, and negative instances to negative instances.</li>
<li>How to handle “ill-formed” negative instances.</li>
<li>Writing the program <code>altersYesToGAGA</code>.</li>
<li>Tying it all together.</li>
</ul></li>
<li>Talk about a reduction from <code>yesOnString</code> to <code>containsGAGAOnString</code>.</li>
<li>Activity 10, first part.</li>
<li>Activity 10, second part.</li>
</ul>
</dd>
<dt>Activity 10</dt>
<dd><ul>
<li>Consider the decision problem <code>IntOnString</code>: It takes two strings <span class="math inline">\(P\)</span>, <span class="math inline">\(I\)</span> as input, and outputs <code>&quot;yes&quot;</code> if <span class="math inline">\(P\)</span> is a program and <span class="math inline">\(P(I)\)</span> is a non-negative integer string (i.e. containing only digits). Similarly to what we did for <code>GAGAOnString</code>, show how <code>YesOnString</code> can be reduced to <code>IntOnString</code>.</li>
<li>Suppose <span class="math inline">\(F\)</span>, <span class="math inline">\(G\)</span> are general computational problems, and <span class="math inline">\(D\)</span> is a decision problem. Also suppose that <span class="math inline">\(F\)</span> reduces to <span class="math inline">\(G\)</span>, and also <span class="math inline">\(D\)</span> reduces to <span class="math inline">\(G\)</span>. What, if anything, can we conclude if:
<ol style="list-style-type: decimal">
<li><span class="math inline">\(D\)</span> is undecidable</li>
<li><span class="math inline">\(G\)</span> is computable</li>
<li><span class="math inline">\(F\)</span> is computable</li>
</ol></li>
</ul>
</dd>
</dl>
<h3 id="day-2-5">Day 2</h3>
<dl>
<dt>Sections 7.4, 7.5</dt>
<dd><ul>
<li>Definition of Turing reduction. (Wahl)</li>
<li>What is an Oracle program. (Wahl)</li>
<li>Propagation of computability. (Wahl)</li>
<li>Is the converse propagation true?</li>
<li>Turing reducibility is transitive. (Wahl)</li>
<li>The problems <code>yesOnEmpty</code>, <code>yesOnAll</code>, <code>yesOnSome</code>.</li>
<li>Refresher on the program <code>ignoreInput</code>.</li>
<li>Use <code>ignoreInput.py</code> to write <code>yesOnString</code> using <code>yesOnEmpty</code> as a helper.</li>
</ul>
</dd>
<dt>Homework 6</dt>
<dd>(Due 10/24 11am in LYN 110) 7.3, 7.5b,c,e (using the “explicit Python program” technique 2 from p. 138), 7.7
</dd>
</dl>
<h2 id="week-7-1015-1019">Week 7 (10/15-10/19)</h2>
<h3 id="day-1-6">Day 1</h3>
<ul>
<li>Fall Break</li>
</ul>
<h3 id="day-2-6">Day 2</h3>
<dl>
<dt>Section 7.5</dt>
<dd><ul>
<li>Review of reduction from <code>yesOnString</code> to <code>yesOnEmpty</code> or <code>yesOnSome</code> or <code>yesOnAll</code>. Sequence diagrams visual. (Wahl)</li>
<li>Definition of what it means for a Python program to <em>halt</em>. (Wahl)</li>
<li>The Halting problem and its variants: <code>haltsOnString</code>, <code>haltsOnEmpty</code>, <code>haltsOnAll</code>, <code>haltsOnSome</code>. (Wahl)</li>
<li>Use an altering technique similar to what we did for <code>GAGAOnString</code> to show a reduction from <code>yesOnString</code> to <code>haltsOnString</code>. (Wahl)</li>
<li>Group activity: Show reduction from <code>haltsOnString</code> to <code>haltsOnEmpty</code>. Include code and sequence diagram.</li>
</ul>
</dd>
<dt>Section 7.6</dt>
<dd><ul>
<li>Group activity: Figure 7.16. Which of these programs actually compute <code>IsEven</code>? Explain.</li>
<li>The problem <code>Computes_F</code> for a computational problem <code>F</code>.</li>
<li>If <code>F</code> is a computable problem, then <code>Computes_F</code> is in fact uncomputable.</li>
<li>The problem <code>ComputesOneOf_S</code>.</li>
</ul>
</dd>
</dl>
<h2 id="week-8-1022-1026">Week 8 (10/22-10/26)</h2>
<h3 id="day-1-7">Day 1</h3>
<dl>
<dt>Sections 8.1, 8.2, 8.3</dt>
<dd><ul>
<li>Parallel computation in Python programs</li>
<li>A parallel computation Python program for containsNANA</li>
<li>Considering this program as a non-deterministic program</li>
<li>Computation Trees, positive/negative/non-terminating leaves (Wahl)</li>
<li>Definition of the output of a nondeterministic computation (Wahl)</li>
<li>Writing pseudocode for recognizer for the concatenation of two recognizable languages.
<ul>
<li>Conclusion: The concatenation of recognizable languages is recognizable.</li>
</ul></li>
</ul>
</dd>
</dl>
<h3 id="day-2-7">Day 2</h3>
<dl>
<dt>Leftover</dt>
<dd><ul>
<li>“Truth table” for “threaded <code>or</code>”</li>
<li>Group activity: “threaded <code>and</code>”</li>
<li>Exercise 8.11: The union of recognizable languages is recognizable.</li>
</ul>
</dd>
<dt>Sections 8.4, 8.5</dt>
<dd><ul>
<li>Non-deterministic Turing Machines</li>
<li>Example of a NDTM detecting if a genetic string contains AAT</li>
<li>Example of a computation in a NDTM: The string AAGAT</li>
<li>Group activity: Describe the full nondeterministic computation for this problem and the string GAATG</li>
<li>Recognizing the union of two recognizable languages via NDTMs</li>
</ul>
</dd>
<dt>Sections 8.6, 8.7, 8.8</dt>
<dd><ul>
<li>Formal definition of NDTM (Wahl)</li>
<li>For every NDTM that solves a problem, there is a DTM that solves it. (Wahl)</li>
<li>If a language and its complement are both recognizable, then the language is decidable. (Wahl)</li>
</ul>
</dd>
<dt>Homework 7</dt>
<dd>(Due 10/30 4pm in LYN 110) 8.4, 8.7, 8.8, 8.9
</dd>
</dl>
<h2 id="week-9-1029-1102">Week 9 (10/29-11/02)</h2>
<h3 id="day-1-8">Day 1</h3>
<dl>
<dt>Homework review</dt>
<dd><ul>
<li>Exercise 7.7</li>
</ul>
</dd>
<dt>Chapter 8 wrap-up</dt>
<dd><ul>
<li>Let <span class="math inline">\(L\)</span> be an undecidable language. If <span class="math inline">\(L\)</span> is recognizable, then the complement of <span class="math inline">\(L\)</span> is unrecognizable. (Wahl)</li>
<li>Co-recognizable languages. Venn diagram of languages and recognizability. (Wahl)</li>
<li>Examples of unrecognizable languages. (Wahl)</li>
</ul>
</dd>
<dt>Sections 9.1, 9.2</dt>
<dd><ul>
<li>Definition of a Deterministic FA (DFA)</li>
<li>Finite Automata and their difference from Turing Machines
<ul>
<li>Only read the tape</li>
<li>Blank symbol transitions to accept/reject state</li>
<li>No halt state</li>
<li>Possible results of running a DFA on a string input</li>
</ul></li>
<li>Notation for finite automata</li>
<li>The “standard” definition for DFAs</li>
<li>Non-deterministic FAs (NFAs)
<ul>
<li>Allowing epsilon transitions</li>
</ul></li>
<li>NFA accepting a string</li>
<li>Example on figure 9.5</li>
<li>Group activity: Draw an NFA that accepts exactly the strings that are concatenation of zero or more of the strings <code>aab</code> or <code>ac</code> (in any order). For example: <code>aabacacaab</code> would be accepted. Use as few states as possible (doable with 5).</li>
</ul>
</dd>
<dt>Section 9.3</dt>
<dd><ul>
<li>Every nfa is equivalent to some dfa</li>
<li>Standard proof: The dfa states represent sets of states from the nfa
<ul>
<li>Figure 9.6</li>
<li>Epsilon closures</li>
</ul></li>
<li>Group activity: Construct a dfa equivalent to the nfa in problem 9.7</li>
<li>Group activity: Construct a dfa equivalent to the nfa you built for strings of <code>aab</code> and <code>ac</code> earlier.</li>
</ul>
</dd>
<dt>Homework 8</dt>
<dd>(Due 11/06 4pm in LYN 110): 9.3, 9.7a, 9.8, 9.9
</dd>
</dl>
<h3 id="day-2-8">Day 2</h3>
<dl>
<dt>Section 9.3 Wrap-up</dt>
<dd><ul>
<li>Strict nfas (Wahl)</li>
<li>Converting from an nfa to a strict nfa (Figure 9.5) (Wahl)</li>
</ul>
</dd>
<dt>Section 9.4</dt>
<dd><ul>
<li>Pure regular expressions
<ul>
<li>Examples on page 177</li>
</ul></li>
<li>The language represented by a regular expression</li>
<li>Standard regular expressions
<ul>
<li>Dot, plus, square brackets</li>
</ul></li>
<li>Converting from a regular expression to an NFA recognizing the same language
<ul>
<li>Single letters</li>
<li>The empty string</li>
<li>Concatenation of two regexs</li>
<li>Alternative of two regexs</li>
<li>Kleene star of two regexs</li>
</ul></li>
<li>Converting a dfa to a regex:
<ul>
<li>Reduce the dfa, labeling transitions with regexs instead of just alphabet letters</li>
<li>At each stage, eliminate a non-start non-accept state and update transitions</li>
<li>Result is a dfa like bottom of page 179</li>
</ul></li>
</ul>
</dd>
</dl>
<h2 id="week-10-1105-1109">Week 10 (11/05-11/09)</h2>
<h3 id="day-1-9">Day 1</h3>
<dl>
<dt>Sections 9.5-9.7</dt>
<dd><ul>
<li>Regular languages (Wahl)</li>
<li>Combining regular languages: (Wahl)
<ul>
<li>The union, complement, intersection, star, and reverse of regular languages is regular</li>
</ul></li>
<li>The non-regular language GnTn. (Wahl)
<ul>
<li>Intuitive explanation of why this language is not regular (Wahl)</li>
</ul></li>
<li>Idea of pumping before <span class="math inline">\(n\)</span>. (Wahl)</li>
</ul>
</dd>
</dl>
<h3 id="day-2-9">Day 2</h3>
<ul>
<li><a href="midterm2_study_guide.html">Midterm 2</a></li>
</ul>
<h2 id="week-11-1112-1116">Week 11 (11/12-11/16)</h2>
<h3 id="day-1-10">Day 1</h3>
<dl>
<dt>Sections 9.6-9.7 wrap-up</dt>
<dd><ul>
<li>Proving a language is not regular (Pumping Lemma) (Wahl)</li>
<li>Examples of non-regular languages (Wahl)</li>
<li>Language of properly-nested parentheses (Wahl)</li>
</ul>
</dd>
<dt>CFG notes 5.1</dt>
<dd><ul>
<li>Motivation for CFGs: Interpreting programming language code
<ul>
<li>Challenges when processing an arithmetic expression</li>
</ul></li>
<li>Informal CFG (recursive) description of the properly-nested-parentheses language.
<ul>
<li>Show two different grammars</li>
</ul></li>
</ul>
</dd>
<dt>Homework 9</dt>
<dd>(Due 11/20 4pm in LYN 110): 9.12, 9.13, 9.17a,b,f,g
</dd>
</dl>
<h3 id="day-2-10">Day 2</h3>
<p>Ice Day</p>
<h2 id="week-12-1119-1123">Week 12 (11/19-11/23)</h2>
<h3 id="day-1-11">Day 1</h3>
<dl>
<dt>CFG notes 5.1, 5.2 (5.2.1-5.2.3)</dt>
<dd><ul>
<li>Informal description of grammar for GnTn and matched parentheses</li>
<li>Definition of CFGs (and CFLs):
<ul>
<li>Terminals/(Terminal) symbols</li>
<li>Non-terminals/variables</li>
<li>Start variable</li>
<li>Production rules</li>
</ul></li>
<li>A grammar for (tokenized) arithmetic expressions involving a token/terminal <span class="math inline">\(v\)</span> representing variables, a token/terminal <span class="math inline">\(n\)</span> representing numbers, and tokens/terminals for the operations of addition (<span class="math inline">\(+\)</span>) and multiplication (<span class="math inline">\(*\)</span>).</li>
<li>Group activity: Write down a grammar for palindrome strings on the symbols <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>.</li>
<li>Group activity: Expand the grammar for arithmetic expressions to also include parentheses.</li>
<li>Show that every regular language is context-free. (Wahl)</li>
<li>Building strings in a grammar:
<ul>
<li>recursive inference (body to head)</li>
<li>derivation (head to body)</li>
<li>Examples from the matched parentheses language</li>
</ul></li>
<li>The Parse tree corresponding to a derivation
<ul>
<li>Labeling of nodes and leaves</li>
</ul></li>
<li>Notation for derivations
<ul>
<li>Sentential forms</li>
<li>Origin of name “context-free”</li>
</ul></li>
<li>Examples of derivations in our arithmetic expressions language.</li>
</ul>
</dd>
<dt>Homework 10</dt>
<dd>(Due 11/28 4pm) CFG Notes (page 168) 5.1.1a,b,c, 5.1.2, 5.2.1
</dd>
</dl>
<h3 id="day-2-11">Day 2</h3>
<ul>
<li>Thanksgiving Break</li>
</ul>
<h2 id="week-13-1126-1130">Week 13 (11/26-11/30)</h2>
<h3 id="day-1-12">Day 1</h3>
<ul>
<li><a href="notes/new_cfg_pushdown.html">Notes</a></li>
<li>Mention pumping lemma for CFLs and examples of non-CFLs</li>
<li>Pushdown automata
<ul>
<li>definition</li>
<li>basic example</li>
<li>CFG -&gt; PDA construction</li>
<li>emptying the stack of a pda</li>
</ul></li>
</ul>
<h3 id="day-2-12">Day 2</h3>
<ul>
<li><a href="notes/parsing.html">Notes</a></li>
<li>Parsing
<ul>
<li>First and Follow sets</li>
<li>LL parsers</li>
</ul></li>
</ul>
<h2 id="week-14-1203-1207">Week 14 (12/03-12/07)</h2>
<h3 id="day-1-13">Day 1</h3>
<ul>
<li><a href="notes/parsing.html">Notes</a></li>
<li>Parsing
<ul>
<li>LR parsers</li>
</ul></li>
</ul>
<h3 id="day-2-13">Day 2</h3>
<ul>
<li>Review</li>
</ul>
</body>
</html>
