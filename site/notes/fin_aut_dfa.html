<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="http://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="finite-automata">Finite Automata</h1>
<p>In this section we start our formal investigations into various models of computation, starting with one of the simplest forms: finite automata.</p>
<h2 id="reading">Reading</h2>
<p>Sections 1.1</p>
<p>Practice problems (page 83): 1.1, 1.3, 1.4, 1.6, 1.36, 1.37</p>
<h2 id="finite-automata-1">Finite Automata</h2>
<h3 id="examples-and-state-diagrams">Examples and State Diagrams</h3>
<p>The idea of a finite automaton is simple:</p>
<ul>
<li>You have some number of “states” that you can be in.</li>
<li>There is some state you start from.</li>
<li>Then on each input there’s a specific state you go to. And you forget everything about what happened before.</li>
<li>When you run out of input, you look at the state you are in, and see if it is one of the select few states that would be considered “final”.</li>
</ul>
<p>We usually represent finite automata via a <strong>state diagram</strong>:</p>
<blockquote>
<p>In the **state diagram for a finite automaton, you have: - One “circle” for each state. - For each state arrows going out to other states, with a label on the arrows indicating the inputs for which they are applicable. - An arrow coming from nowhere indicates the <em>start state</em>. - An extra circle around a state indicates it is an <em>accept state</em>.</p>
</blockquote>
<p>As an example, let us think of inputs being binary numbers (only <span class="math">\(0\)</span> and <span class="math">\(1\)</span> as digits), and we want a finite automaton that detects if the number is divisible by <span class="math">\(3\)</span>. Recall that a number is divisible by <span class="math">\(3\)</span> if and only if the sum of its digits are. Since we see the digits one at a time, we will keep track of the remainder on division by <span class="math">\(3\)</span> at each stage. So:</p>
<ul>
<li>We will have 3 states, one for remainder <span class="math">\(0\)</span>, one for remainder <span class="math">\(1\)</span> and one for remainder <span class="math">\(2\)</span>.</li>
<li>The <span class="math">\(0\)</span> state is the start state.</li>
<li>The <span class="math">\(0\)</span> state is also the only accept state.</li>
<li>From each state we have an arrow to itself, for input <code>0</code>.</li>
<li>For input <code>1</code> we have arrows from state <span class="math">\(0\)</span> to state <span class="math">\(1\)</span>, from state <span class="math">\(1\)</span> to state <span class="math">\(2\)</span> and from state <span class="math">\(2\)</span> to state <span class="math">\(0\)</span>.</li>
</ul>
<p>Now as practice for you: Suppose we want a finite automaton that detects division by <span class="math">\(7\)</span>. We can still do it by keeping track of the remainder, but some changes would need to be made:</p>
<ul>
<li>We now have <span class="math">\(7\)</span> states, corresponding to the remainders <span class="math">\(0\)</span> through <span class="math">\(6\)</span>.</li>
<li>If we are at a state <span class="math">\(k\)</span>, meaning the remainder of our current number when divided by <span class="math">\(7\)</span> is <span class="math">\(k\)</span>, then we need to figure out what happens when we add one more digit. This is easy to do because of the properties of modular arithmetic, and because we can describe the effect of adding one more digit to the number: The number is doubled, and increased by the digit we are adding.</li>
<li>So for example if we are at state <span class="math">\(3\)</span>, meaning the remainder is now <span class="math">\(3\)</span>, then on an input <code>0</code> we got to state <span class="math">\(6\)</span> and on input <code>1</code> we go to state <span class="math">\(0\)</span>.</li>
<li>Similarly if we are at state <span class="math">\(5\)</span>, then because <span class="math">\(2\times 5 = 3 \mod 7\)</span> we would be going to state <span class="math">\(3\)</span> on input <code>0</code> and to state <code>4</code> on input <code>1</code>.</li>
</ul>
<p>Exercise 1.37 asks you to generalize this idea.</p>
<h3 id="formal-definitions">Formal Definitions</h3>
<p>Eventually we want to have clear unambiguous definitions, so here is a more precise definition of finite automata:</p>
<blockquote>
<p>A <strong>(Deterministic) Finite Automaton</strong> (DFA) is a <span class="math">\(5\)</span>-tuple <span class="math">\((Q, \Sigma, \delta, q_0, F)\)</span>, where: - <span class="math">\(Q\)</span> is a finite set, called the <em>states</em>, - <span class="math">\(\Sigma\)</span> is a finite set, called the <em>alphabet</em>, - <span class="math">\(\delta\colon Q\times \Sigma \to Q\)</span> is the <em>transition function</em>, - <span class="math">\(q_0\in Q\)</span> is the <em>start state</em>, (in particular <span class="math">\(Q\)</span> must be nonempty) - <span class="math">\(F\subset Q\)</span> is the set of <em>accept or final states</em> (possibly empty)</p>
</blockquote>
<p>Question 1: What happens if <span class="math">\(F\)</span> is the empty set? What if <span class="math">\(F = S\)</span>?</p>
<p>Question 2: Use this formal definition to describe the automaton for division by <span class="math">\(3\)</span> that we described earlier.</p>
<p>Question 3: Do the same for the automaton for division by <span class="math">\(2\)</span>.</p>
<p>We now discuss the meaning of computation in this setting. Informally we compute as follows:</p>
<ul>
<li>We start at the start state.</li>
<li>We also have a string from <span class="math">\(\Sigma\)</span>. We want to see if the DFA will accept it.</li>
<li>We go through each letter in the string in order, and use the <span class="math">\(\delta\)</span> function to transition to a new state each time.</li>
<li>When we run out of input, we see if we are at an accept/final state. If so then we “accept” the string.</li>
</ul>
<p>More formally:</p>
<blockquote>
<p>Suppose <span class="math">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> is a DFA. - If <span class="math">\(w=w_1w_2\cdots w_n\)</span> is a string, where each <span class="math">\(w_i\in\Sigma\)</span>, then we say that the DFA <span class="math">\(M\)</span> <strong>accepts</strong> the string <span class="math">\(w\)</span> if there is a sequence of states <span class="math">\(r_0,\ldots,r_n\)</span> such that: - <span class="math">\(r_0 = q_0\)</span> is the start state - <span class="math">\(\delta(r_i, w_{i+1}) = r_{i+1}\)</span>, i.e. each new input moves us to the next state - <span class="math">\(r_n\in F\)</span>, i.e. the last state is in the special subset of accept states. - We say that the DFA <span class="math">\(M\)</span> <strong>recognizes</strong> the language <span class="math">\(L\)</span>, and we write <span class="math">\(L(M) = L\)</span>, if <span class="math">\(M\)</span> accepts exactly those strings that are in <span class="math">\(L\)</span>. - A language is called a <strong>regular language</strong> if there is a DFA that recognizes it.</p>
</blockquote>
<p>Note that there might be many DFAs all recognizing the same language. But for a given DFA there is exactly one language it recognizes, namely the language of all strings in <span class="math">\(\Sigma\)</span> that the DFA accepts.</p>
</body>
</html>
